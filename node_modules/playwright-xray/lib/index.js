"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const picocolors_1 = require("picocolors");
const xray_service_1 = require("./xray.service");
const help_1 = __importDefault(require("./help"));
class XrayReporter {
    constructor(options) {
        this.testCaseKeyPattern = /^(.*?) |$/;
        this.receivedRegEx = /Received string: "(.*?)"(?=\n)/;
        this.defaultRunName = `[${new Date().toUTCString()}] - Automated run`;
        this.options = options;
        this.help = new help_1.default(this.options.jira.type);
        this.xrayService = new xray_service_1.XrayService(this.options);
        this.totalDuration = 0;
        const testResults = {
            testExecutionKey: this.options.testExecution,
            info: {
                summary: this.defaultRunName,
                startDate: this.help.getFormatData(new Date()),
                finishDate: this.help.getFormatData(new Date()),
                testPlanKey: this.options.testPlan,
                revision: this.options.revision,
                description: this.options.description,
                testEnvironments: this.options.testEnvironments,
                version: this.options.version,
            },
            tests: [],
        };
        this.testResults = testResults;
        console.log(`${(0, picocolors_1.bold)((0, picocolors_1.blue)(`-------------------------------------`))}`);
        console.log(`${(0, picocolors_1.bold)((0, picocolors_1.blue)(` `))}`);
        this.execInfo = {
            browserName: '',
        };
    }
    onBegin(config, suite) {
        config.projects.forEach((p, index) => {
            this.execInfo.browserName += index > 0 ? ', ' : '';
            this.execInfo.browserName += p.name.charAt(0).toUpperCase() + p.name.slice(1);
        });
        console.log(`${(0, picocolors_1.bold)((0, picocolors_1.yellow)(`⏺  `))}${(0, picocolors_1.bold)((0, picocolors_1.blue)(`Starting the run with ${suite.allTests().length} tests`))}`);
        console.log(`${(0, picocolors_1.bold)((0, picocolors_1.blue)(` `))}`);
    }
    async onTestEnd(testCase, result) {
        const testCaseId = testCase.title.match(this.testCaseKeyPattern);
        const testCode = testCaseId != null ? testCaseId[1] : '';
        if (testCode != '') {
            // @ts-ignore
            const finishTime = new Date(result.startTime.getTime() + result.duration);
            this.totalDuration = this.totalDuration + result.duration;
            let xrayTestData = {
                testKey: testCode,
                status: this.help.convertPwStatusToXray(result.status),
                start: this.help.getFormatData(result.startTime),
                finish: this.help.getFormatData(finishTime),
                steps: [],
                comment: '',
            };
            // Set Test Error
            if (result.errors.length > 0) {
                xrayTestData.comment = JSON.stringify(result.errors);
            }
            else {
                await Promise.all(result.steps.map(async (step) => {
                    if (step.category != 'hook') {
                        // Add Step to request
                        const errorMessage = step.error?.stack
                            ?.toString()
                            ?.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
                        const received = this.receivedRegEx.exec(errorMessage);
                        let dataReceived = '';
                        if (received?.[1] !== undefined) {
                            dataReceived = received?.[1];
                        }
                        const xrayTestStep = {
                            status: typeof step.error == 'object' ? this.help.convertPwStatusToXray('failed') : this.help.convertPwStatusToXray('passed'),
                            comment: typeof step.error == 'object' ? errorMessage : '',
                            actualResult: dataReceived,
                        };
                        xrayTestData.steps.push(xrayTestStep);
                    }
                }));
            }
            // Get evidences from test results (video, images, text)
            const evidences = [];
            if (result.attachments.length > 0) {
                result.attachments.map(async (attach) => {
                    const filename = path.basename(attach.path);
                    const attachData = fs.readFileSync(attach.path, { encoding: 'base64' });
                    const evid = {
                        data: attachData,
                        filename: filename,
                        contentType: attach.contentType,
                    };
                    evidences.push(evid);
                });
            }
            xrayTestData.evidence = evidences;
            this.testResults.tests.push(xrayTestData);
            let browser = '';
            if (testCase.parent.parent !== undefined) {
                browser = testCase.parent.parent?.title;
                browser = browser.charAt(0).toUpperCase() + browser.slice(1) + ' | ';
            }
            switch (this.help.convertPwStatusToXray(result.status)) {
                case 'PASS':
                case 'PASSED':
                    console.log(`${(0, picocolors_1.bold)((0, picocolors_1.green)(`✅ ${browser}${testCase.title}`))}`);
                    break;
                case 'FAIL':
                case 'FAILED':
                    console.log(`${(0, picocolors_1.bold)((0, picocolors_1.red)(`⛔ ${browser}${testCase.title}`))}`);
                    break;
                case 'SKIPPED':
                case 'ABORTED':
                    console.log(`${(0, picocolors_1.bold)((0, picocolors_1.yellow)(`🚫 ${browser}${testCase.title}`))}`);
                    break;
            }
        }
    }
    async onEnd() {
        // Update test Duration
        this.testResults.info.finishDate = this.help.getFormatData(new Date(new Date((this.testResults && this.testResults.info ? this.testResults.info.startDate : undefined)).getTime() + this.totalDuration));
        if (typeof this.testResults != 'undefined' && typeof this.testResults.tests != 'undefined' && this.testResults.tests.length > 0) {
            await this.xrayService.createRun(this.testResults, this.execInfo);
        }
        else {
            console.log(`There are no tests with such ${this.testCaseKeyPattern} key pattern`);
        }
    }
}
exports.default = XrayReporter;
