"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const azdev = __importStar(require("azure-devops-node-api"));
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const debug_1 = __importDefault(require("./debug"));
const utils_1 = require("./utils");
var EAzureTestStatuses;
(function (EAzureTestStatuses) {
    EAzureTestStatuses["passed"] = "Passed";
    EAzureTestStatuses["failed"] = "Failed";
    EAzureTestStatuses["skipped"] = "Paused";
    EAzureTestStatuses["timedOut"] = "Failed";
    EAzureTestStatuses["interrupted"] = "Failed";
})(EAzureTestStatuses || (EAzureTestStatuses = {}));
const attachmentTypesArray = ['screenshot', 'video', 'trace'];
class AzureDevOpsReporter {
    _debug = (0, debug_1.default)('azure');
    _debugWarning = (0, debug_1.default)('azure:warning');
    _testApi;
    _coreApi;
    _publishedResultsCount = 0;
    _testsAliasToBePublished = [];
    _testResultsToBePublished = [];
    _connection;
    _orgUrl;
    _projectName;
    _environment;
    _planId = 0;
    _logging = false;
    _isDisabled = false;
    _testRunTitle = '';
    _uploadAttachments = false;
    _attachmentsType = [];
    _token = '';
    _runIdPromise;
    _resolveRunId = () => { };
    _rejectRunId = () => { };
    _publishResultsPromise;
    _resolvePublishResults = () => { };
    _rejectPublishResults = () => { };
    _testRunConfig = {};
    _testPointMapper;
    _azureClientOptions = {
        allowRetries: true,
        maxRetries: 20,
    };
    _publishTestResultsMode = 'testResult';
    constructor(options) {
        this._runIdPromise = new Promise((resolve, reject) => {
            this._resolveRunId = resolve;
            this._rejectRunId = reject;
        })
            .then((runId) => {
            return runId;
        })
            .catch((error) => {
            this._warning(error);
            this._isDisabled = true;
        });
        this._publishResultsPromise = new Promise((resolve, reject) => {
            this._resolvePublishResults = resolve;
            this._rejectPublishResults = reject;
        })
            .then((runId) => {
            return runId;
        })
            .catch((error) => {
            this._warning(error);
            this._isDisabled = true;
        });
        // this is the default implementation, might be replaced by the options
        this._testPointMapper = async (testCase, testPoints) => {
            if (testPoints.length > 1) {
                this._warning(`There are ${testPoints.length} testPoints found for the test case \n\t ${testCase.title}, \n\t you should set testRunConfig.configurationIds and/or use set a testPointMapper!`);
            }
            return testPoints;
        };
        this._validateOptions(options);
    }
    _validateOptions(options) {
        if (options?.isDisabled) {
            this._isDisabled = true;
            return;
        }
        if (!options?.orgUrl) {
            this._warning("'orgUrl' is not set. Reporting is disabled.");
            this._isDisabled = true;
            return;
        }
        if (!options?.projectName) {
            this._warning("'projectName' is not set. Reporting is disabled.");
            this._isDisabled = true;
            return;
        }
        if (!options?.planId) {
            this._warning("'planId' is not set. Reporting is disabled.");
            this._isDisabled = true;
            return;
        }
        if (!options?.token) {
            this._warning("'token' is not set. Reporting is disabled.");
            this._isDisabled = true;
            return;
        }
        if (options?.uploadAttachments) {
            if (!options?.attachmentsType) {
                this._warning("'attachmentsType' is not set. Attachments Type will be set to 'screenshot' by default.");
                this._attachmentsType = [new RegExp('screenshot')];
            }
            else {
                this._attachmentsType = options.attachmentsType.map((pattern) => {
                    if (pattern instanceof RegExp) {
                        return pattern;
                    }
                    else {
                        return new RegExp(pattern);
                    }
                });
            }
        }
        this._orgUrl = options.orgUrl;
        this._projectName = options.projectName;
        this._planId = options.planId;
        this._logging = options.logging || false;
        this._token = options.token;
        this._environment = options?.environment || undefined;
        this._testRunTitle =
            `${this._environment ? `[${this._environment}]:` : ''} ${options?.testRunTitle || 'Playwright Test Run'}` ||
                `${this._environment ? `[${this._environment}]:` : ''}Test plan ${this._planId}`;
        this._uploadAttachments = options?.uploadAttachments || false;
        this._connection = new azdev.WebApi(this._orgUrl, azdev.getPersonalAccessTokenHandler(this._token), this._azureClientOptions);
        this._testRunConfig = options?.testRunConfig || undefined;
        this._publishTestResultsMode = options?.publishTestResultsMode || 'testResult';
        if (options.testPointMapper) {
            this._testPointMapper = options.testPointMapper;
        }
        if (this._logging) {
            debug_1.default.enable('azure');
        }
    }
    async onBegin() {
        if (this._isDisabled)
            return;
        try {
            this._testApi = await this._connection.getTestApi();
            if (this._publishTestResultsMode === 'testResult') {
                const run = await this._createRun(this._testRunTitle);
                if (run?.id) {
                    this._resolveRunId(run.id);
                    this._log(chalk_1.default.green(`Using run ${run.id} to publish test results`));
                }
                else {
                    this._isDisabled = true;
                    this._rejectRunId('Failed to create test run. Reporting is disabled.');
                }
            }
        }
        catch (error) {
            this._isDisabled = true;
            if (error.message.includes('401')) {
                this._warning('Failed to create test run. Check your token. Reporting is disabled.');
            }
            else if (error.message.includes('getaddrinfo ENOTFOUND')) {
                this._warning('Failed to create test run. Check your orgUrl. Reporting is disabled.');
            }
            else {
                this._warning('Failed to create test run. Reporting is disabled.');
                const parsedError = JSON.parse(String(error.message.trim()));
                this._warning(parsedError?.message || error.message);
            }
        }
    }
    async onTestEnd(test, testResult) {
        if (this._isDisabled)
            return;
        try {
            if (this._publishTestResultsMode === 'testResult') {
                const runId = await this._runIdPromise;
                if (!runId)
                    return;
                this._logTestItem(test, testResult);
                await this._publishCaseResult(test, testResult);
            }
            else {
                this._logTestItem(test, testResult);
                const caseIds = this._getCaseIds(test);
                if (!caseIds || !caseIds.length)
                    return;
                const testCase = {
                    ...test,
                    testAlias: `${(0, utils_1.shortID)()} - ${test.title}`,
                    testCaseIds: caseIds,
                };
                this._testResultsToBePublished.push({ testCase: testCase, testResult });
            }
        }
        catch (error) {
            this._warning(`Failed to publish test result. \n ${error.message}`);
        }
    }
    async onEnd() {
        if (this._isDisabled)
            return;
        try {
            let runId;
            if (this._publishTestResultsMode === 'testResult') {
                runId = await this._runIdPromise;
                let prevCount = this._testsAliasToBePublished.length;
                while (this._testsAliasToBePublished.length > 0) {
                    // need wait all results to be published
                    if (prevCount > this._testsAliasToBePublished.length) {
                        this._log(chalk_1.default.gray(`Waiting for all results to be published. Remaining ${this._testsAliasToBePublished.length} results`));
                        prevCount--;
                    }
                    await new Promise((resolve) => setTimeout(resolve, 250));
                }
            }
            else {
                this._logging = true;
                if (this._testResultsToBePublished.length === 0) {
                    this._log(chalk_1.default.gray('No test results to publish'));
                    return;
                }
                else {
                    const createRunResponse = await this._createRun(this._testRunTitle);
                    runId = createRunResponse?.id;
                    if (runId) {
                        this._resolveRunId(runId);
                        this._log(chalk_1.default.green(`Using run ${runId} to publish test results`));
                        await this._publishTestResults(runId, this._testResultsToBePublished);
                    }
                    else {
                        this._isDisabled = true;
                        this._rejectRunId('Failed to create test run. Reporting is disabled.');
                    }
                    await this._publishResultsPromise;
                }
            }
            if (this._publishedResultsCount === 0 && !runId) {
                this._log(chalk_1.default.gray('No testcases were matched. Ensure that your tests are declared correctly.'));
                return;
            }
            if (!this._testApi)
                this._testApi = await this._connection.getTestApi();
            const runUpdatedResponse = await this._testApi.updateTestRun({ state: 'Completed' }, this._projectName, runId);
            this._log(chalk_1.default.green(`Run ${runId} - ${runUpdatedResponse.state}`));
        }
        catch (error) {
            this._warning(chalk_1.default.red(`Error on completing run ${error}`));
        }
    }
    printsToStdio() {
        return true;
    }
    _log(message) {
        if (this._logging) {
            debug_1.default.enable('azure');
            this._debug(message);
        }
    }
    _warning(message) {
        debug_1.default.enable('azure:warning');
        this._debugWarning(`${chalk_1.default.yellow(message)}`);
    }
    _getCaseIds(test) {
        const result = [];
        const regex = new RegExp(/\[([\d,\s]+)\]/, 'gm');
        const matchesAll = test.title.matchAll(regex);
        const matches = [...matchesAll].map((match) => match[1]);
        matches.forEach((match) => {
            const ids = match.split(',').map((id) => id.trim());
            result.push(...ids);
        });
        return result;
    }
    _logTestItem(test, testResult) {
        switch (testResult.status) {
            case 'passed':
                this._log(chalk_1.default.green(`${test.title} - ${testResult.status}`));
                break;
            case 'failed':
                this._log(chalk_1.default.red(`${test.title} - ${testResult.status}`));
                break;
            case 'timedOut':
                this._log(chalk_1.default.yellow(`${test.title} - ${testResult.status}`));
                break;
            case 'skipped':
                this._log(chalk_1.default.yellow(`${test.title} - ${testResult.status}`));
                break;
            case 'interrupted':
                this._log(chalk_1.default.red(`${test.title} - ${testResult.status}`));
                break;
            default:
                this._log(`${test.title} - ${testResult.status}`);
                break;
        }
    }
    async _createRun(runName) {
        try {
            const isExists = await this._checkProject(this._projectName);
            if (!isExists) {
                return;
            }
            else {
                const runModel = {
                    name: runName,
                    automated: true,
                    plan: { id: String(this._planId) },
                    ...(this._testRunConfig
                        ? this._testRunConfig
                        : {
                            configurationIds: [1],
                        }),
                };
                if (!this._testApi)
                    this._testApi = await this._connection.getTestApi();
                const adTestRun = await this._testApi.createTestRun(runModel, this._projectName);
                if (adTestRun?.id)
                    return adTestRun;
                else
                    throw new Error('Failed to create test run');
            }
        }
        catch (error) {
            this._warning(chalk_1.default.red(error.message));
            this._isDisabled = true;
        }
    }
    _removePublished(testAlias) {
        const resultIndex = this._testsAliasToBePublished.indexOf(testAlias);
        if (resultIndex !== -1)
            this._testsAliasToBePublished.splice(resultIndex, 1);
    }
    async _checkProject(projectName) {
        try {
            if (!this._coreApi)
                this._coreApi = await this._connection.getCoreApi();
            const project = await this._coreApi.getProject(projectName);
            if (project)
                return project;
            else
                throw new Error(`Project ${projectName} does not exist. Reporting is disabled.`);
        }
        catch (error) {
            this._warning(chalk_1.default.red(error.message));
            this._isDisabled = true;
        }
    }
    async _getTestPointsOfTestResults(planId, testsResults) {
        const result = new Map();
        try {
            const testcaseIds = testsResults.map((t) => t.testCase.testCaseIds.map((id) => parseInt(id, 10))).flat();
            const pointsQuery = {
                pointsFilter: { testcaseIds: testcaseIds },
            };
            if (!this._testApi)
                this._testApi = await this._connection.getTestApi();
            const pointsQueryResult = await this._testApi.getPointsByQuery(pointsQuery, this._projectName);
            if (pointsQueryResult.points) {
                for (const testsResult of testsResults) {
                    const currentTestPoints = pointsQueryResult.points?.filter((testPoint) => {
                        if (!testPoint.testPlan.id || parseInt(testPoint.testPlan.id, 10) !== planId) {
                            // the testPlan id is not matching
                            return false;
                        }
                        else if (!testPoint.testCase.id ||
                            !testsResult.testCase.testCaseIds.find((testCaseId) => testPoint.testCase.id == testCaseId)) {
                            // the testCase id is not matching
                            return false;
                        }
                        else if (this._testRunConfig && this._testRunConfig.configurationIds?.length) {
                            // configuration ids are set, so they must match
                            return (testPoint.configuration.id &&
                                this._testRunConfig.configurationIds.includes(parseInt(testPoint.configuration.id, 10)));
                        }
                        else {
                            // no configuration ids to filter, ignore them
                            return true;
                        }
                    });
                    if (currentTestPoints && currentTestPoints.length > 0) {
                        const mappedTestPoints = await this._testPointMapper(testsResult.testCase, currentTestPoints);
                        if (mappedTestPoints && mappedTestPoints.length > 0) {
                            result.set(testsResult, mappedTestPoints);
                        }
                        else {
                            // logging will happen outside
                            result.set(testsResult, []);
                        }
                    }
                    else {
                        // logging will happen outside
                        result.set(testsResult, []);
                    }
                }
            }
        }
        catch (error) {
            this._warning(chalk_1.default.red(error.message));
        }
        return result;
    }
    _addReportingOverride = (api) => {
        /**
         * Override the default behavior of publishing test results to the test run.
         * This is necessary because Microsoft Azure API documentation at version higher than '5.0-preview.5'
         * has undocumented fields and they not implementing at 'azure-devops-node-api/TestApi' package.
         * This function is downgraded the API version to '5.0-preview.5'.
         * https://github.com/microsoft/azure-devops-node-api/issues/318#issuecomment-498802402
         */
        api.addTestResultsToTestRun = function (results, projectName, runId) {
            return new Promise(async (resolve, reject) => {
                const routeValues = {
                    project: projectName,
                    runId,
                };
                try {
                    const verData = await this.vsoClient.getVersioningData('5.0-preview.5', 'Test', '4637d869-3a76-4468-8057-0bb02aa385cf', routeValues);
                    const url = verData.requestUrl;
                    const options = this.createRequestOptions('application/json', verData.apiVersion);
                    const res = await this.rest.create(url, results, options);
                    resolve(res);
                }
                catch (error) {
                    reject(error);
                }
            });
        };
        return api;
    };
    async _uploadAttachmentsFunc(testResult, testCaseResultId, test) {
        this._log(chalk_1.default.gray(`Uploading attachments for test: ${test.title}`));
        const runId = await this._runIdPromise;
        const attachmentsResult = [];
        if (!runId) {
            throw new Error('Could not find test run id. Check, maybe testPlanId, what you specified, is incorrect.');
        }
        for (const attachment of testResult.attachments) {
            try {
                if (this._attachmentsType.find((regex) => regex.test(attachment.name))) {
                    let attachmentRequestModel;
                    const name = attachment.name.split(/[^a-zA-Z0-9]+/).join('_') + '_' + (0, utils_1.createGuid)();
                    if (attachment.body) {
                        const ext = (0, utils_1.getExtensionFromContentType)(attachment.contentType);
                        attachmentRequestModel = {
                            attachmentType: 'GeneralAttachment',
                            fileName: name + '.' + ext,
                            stream: attachment.body.toString('base64'),
                        };
                    }
                    else if ((0, fs_1.existsSync)(attachment.path)) {
                        const ext = (0, utils_1.getExtensionFromFilename)(attachment.path);
                        attachmentRequestModel = {
                            attachmentType: 'GeneralAttachment',
                            fileName: name + '.' + ext,
                            stream: (0, fs_1.readFileSync)(attachment.path, { encoding: 'base64' }),
                        };
                    }
                    else {
                        throw new Error(`Attachment ${attachment.path} does not exist`);
                    }
                    if (!this._testApi)
                        this._testApi = await this._connection.getTestApi();
                    const response = await this._testApi.createTestResultAttachment(attachmentRequestModel, this._projectName, runId, testCaseResultId);
                    if (!response?.id)
                        throw new Error(`Failed to upload attachment for test: ${test.title}`);
                    attachmentsResult.push(response.url);
                }
            }
            catch (error) {
                this._warning(chalk_1.default.red(error.message));
            }
        }
        this._log(chalk_1.default.gray('Uploaded attachments'));
        return attachmentsResult;
    }
    async _publishCaseResult(test, testResult) {
        const caseIds = this._getCaseIds(test);
        if (!caseIds || !caseIds.length)
            return;
        const testCase = {
            ...test,
            testAlias: `${(0, utils_1.shortID)()} - ${test.title}`,
            testCaseIds: caseIds,
        };
        this._testsAliasToBePublished.push(testCase.testAlias);
        try {
            const runId = await this._runIdPromise;
            this._log(chalk_1.default.gray(`Start publishing: ${test.title}`));
            const toBePublished = { testCase: testCase, testResult };
            const mappedTestPoints = (await this._getTestPointsOfTestResults(this._planId, [toBePublished])).get(toBePublished);
            if (!mappedTestPoints || mappedTestPoints.length == 0) {
                throw new Error(`No test points found for test case [${caseIds}] associated with test plan ${this._planId}. Check, maybe testPlanId, what you specified, is incorrect.`);
            }
            const results = mappedTestPoints.map((testPoint) => ({
                // the testPoint is the testCase + configuration, there is not need to set these
                testPoint: { id: String(testPoint.id) },
                outcome: EAzureTestStatuses[testResult.status],
                state: 'Completed',
                durationInMs: testResult.duration,
                errorMessage: testResult.error
                    ? `${test.title}: ${testResult.error?.message?.replace(/\u001b\[.*?m/g, '')}`
                    : undefined,
                stackTrace: testResult.error?.stack?.replace(/\u001b\[.*?m/g, ''),
            }));
            if (!this._testApi)
                this._testApi = await this._connection.getTestApi();
            const testCaseResult = (await this._addReportingOverride(this._testApi).addTestResultsToTestRun(results, this._projectName, runId));
            if (!testCaseResult?.result)
                throw new Error(`Failed to publish test result for test cases [${caseIds}]`);
            if (this._uploadAttachments && testResult.attachments.length > 0)
                await this._uploadAttachmentsFunc(testResult, testCaseResult.result.value[0].id, test);
            this._removePublished(testCase.testAlias);
            this._publishedResultsCount++;
            this._log(chalk_1.default.gray(`Result published: ${test.title}`));
            return testCaseResult;
        }
        catch (error) {
            this._removePublished(testCase.testAlias);
            this._warning(chalk_1.default.red(error.message));
        }
    }
    async _publishTestResults(runId, testsResults) {
        if (!this._testApi)
            this._testApi = await this._connection.getTestApi();
        const testsPackSize = 50;
        const testsEndPack = Math.ceil(testsResults.length / testsPackSize);
        const testsPacksArray = Array.from({ length: testsEndPack }, (_, i) => testsResults.slice(i * testsPackSize, (i + 1) * testsPackSize));
        this._log(chalk_1.default.gray(`Start publishing test results for ${testsResults.length} test(s)`));
        try {
            for (const testsPack of testsPacksArray) {
                let testCaseIds = [];
                const withAttachmentsByTestPoint = new Map();
                const testsPointsByTestCase = await this._getTestPointsOfTestResults(this._planId, testsPack);
                const testCaseResults = [];
                for (const [key, value] of testsPointsByTestCase.entries()) {
                    const testCase = key.testCase;
                    const testResult = key.testResult;
                    const testPoints = value;
                    if (testPoints && testPoints.length > 0) {
                        testCaseIds.push(...testCase.testCaseIds);
                        testCaseResults.push(...testPoints.map((testPoint) => ({
                            // the testPoint is the testCase + configuration, there is not need to set these
                            testPoint: { id: String(testPoint.id) },
                            outcome: EAzureTestStatuses[testResult.status],
                            state: 'Completed',
                            durationInMs: testResult.duration,
                            errorMessage: testResult.error
                                ? `${testCase.title}: ${testResult.error?.message?.replace(/\u001b\[.*?m/g, '')}`
                                : undefined,
                            stackTrace: testResult.error?.stack?.replace(/\u001b\[.*?m/g, ''),
                        })));
                        if (this._uploadAttachments && testResult.attachments.length > 0) {
                            for (const testPoint of testPoints) {
                                const tmp = withAttachmentsByTestPoint.get(testPoint);
                                if (!tmp) {
                                    withAttachmentsByTestPoint.set(testPoint, [key]);
                                }
                                else {
                                    // we allready have the test point hit by another testcase, should not happen
                                    tmp.push(key);
                                }
                            }
                        }
                    }
                    else {
                        this._warning(`No test points found for test case [${testCase.testCaseIds}] associated with test plan ${this._planId}. Check, maybe testPlanId, what you specified, is incorrect.`);
                    }
                }
                if (testCaseResults.length === 0) {
                    continue;
                }
                const testCaseResult = (await this._addReportingOverride(this._testApi).addTestResultsToTestRun(testCaseResults, this._projectName, runId));
                if (!testCaseResult.result) {
                    this._warning(`Failed to publish test result for test cases [${testCaseIds.join(', ')}]`);
                }
                else if (testCaseResult.result.count !== testCaseResults.length) {
                    this._warning(`Not all test result for test cases [${testCaseIds.join(', ')}] are published`);
                }
                if (this._uploadAttachments && withAttachmentsByTestPoint.size > 0) {
                    this._log(chalk_1.default.gray(`Starting to uploading attachments for ${withAttachmentsByTestPoint.size} testpoint(s)`));
                    const testResultsQuery = {
                        fields: [''],
                        results: testCaseResult.result.value?.map((r) => {
                            return { id: r.id, testRun: { id: r.testRun?.id } };
                        }),
                    };
                    const resultData = await this._testApi.getTestResultsByQuery(testResultsQuery, this._projectName);
                    for (const [key, value] of withAttachmentsByTestPoint.entries()) {
                        const testResult = resultData.results?.find((result) => result.testPoint?.id === String(key.id));
                        if (!testResult) {
                            this._warning(`Test result for test point [${key.id}] is missing, attachments are not uploaded!`);
                            continue;
                        }
                        for (const withAttachments of value) {
                            await this._uploadAttachmentsFunc(withAttachments.testResult, testResult.id, withAttachments.testCase);
                        }
                    }
                }
                this._publishedResultsCount += testsPack.length;
                this._log(chalk_1.default.gray(`Left to publish: ${testsResults.length - this._publishedResultsCount}`));
            }
            this._log(chalk_1.default.gray(`Test results published for ${this._publishedResultsCount} test(s)`));
            this._resolvePublishResults();
        }
        catch (error) {
            this._warning(chalk_1.default.red(error.message));
            this._rejectPublishResults(error);
        }
    }
}
exports.default = AzureDevOpsReporter;
//# sourceMappingURL=playwright-azure-reporter.js.map